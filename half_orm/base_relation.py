#-*- coding: utf-8 -*-
# pylint: disable=protected-access, too-few-public-methods, no-member

"""This module is used by the `model <#module-half_orm.model>`_ module
to generate the classes that manipulate the data in your database
with the `Model.get_relation_class <#half_orm.model.Model.get_relation_class>`_
method.


Example:
    >>> from half_orm.model import Model
    >>> model = Model('halftest')
    >>> class Person(model.get_relation_class('actor.person')):
    >>>     # your code goes here

Main methods provided by the class Relation:
- ho_insert: inserts a tuple into the pg table.
- ho_select: returns a generator of the elements of the set defined by
  the constraint on the Relation object. The elements are dictionaries with the
  keys corresponding to the selected columns names in the relation.
  The result is affected by the methods: ho_distinct, ho_order_by, ho_limit and ho_offset
  (see below).
- ho_update: updates the set defined by the constraint on the Relation object
  with the values passed as arguments.
- ho_delete: deletes from the relation the set of elements defined by the constraint
  on the Relation object.
- ho_get: returns the unique element defined by the constraint on the Relation object.
  the element returned if of the type of the Relation object.

The following methods can be chained on the object before a select.

- ho_distinct: ensures that there are no duplicates on the select result.
- ho_order_by: sets the order of the select result.
- ho_limit: limits the number of elements returned by the select method.
- ho_offset: sets the offset for the select method.

"""

import inspect
from dataclasses import dataclass
from functools import wraps
from collections import OrderedDict
from typing import List, Generic, TypeVar, Dict
from keyword import iskeyword

from half_orm import relation_errors
from half_orm.transaction import Transaction
from half_orm.field import Field
from half_orm import utils

class _SetOperators:
    """_SetOperators class stores the set operations made on the Relation class objects

    - __operator is one of {'or', 'and', 'sub', 'neg'}
    - __right is a Relation object. It can be None if the operator is 'neg'.
    """
    def __init__(self, left, operator=None, right=None):
        self.__left = left
        self.__operator = operator
        self.__right = right

    @property
    def operator(self):
        """Property returning the __operator value."""
        return self.__operator
    @operator.setter
    def operator(self, operator):
        """Set operator setter."""
        self.__operator = operator

    @property
    def left(self):
        """Returns the left object of the set operation."""
        return self.__left
    @left.setter
    def left(self, left):
        """left operand (relation) setter."""
        self.__left = left

    @property
    def right(self):
        """Property returning the right operand (relation)."""
        return self.__right
    @right.setter
    def right(self, right):
        """right operand setter."""
        self.__right = right

class BaseRelation:
    """Used as a base class for the classes generated by
    `Model.get_relation_class <#half_orm.model.Model.get_relation_class>`_.

    Args:
        **kwargs: the arguments names must correspond to the columns names of the relation.

    Raises:
        UnknownAttributeError: If the name of an argument doesn't match a column name in the
            relation considered.

    Examples:
        You can generate a class for any relation in your database:
            >>> from half_orm.model import Model
            >>> model = Model('halftest')
            >>> class Person(model.get_relation_class('actor.person')):
            >>>     # your code

        To define a set of data in your relation at instantiation:
            >>> gaston = Person(last_name='Lagaffe', first_name='Gaston')
            >>> all_names_starting_with_la = Person(last_name=('ilike', 'la%'))

        Or to constrain an instantiated object via its\
            `Fields <#half_orm.field.Field>`_:
            >>> person = Person()
            >>> person.birth_date = ('>', '1970-01-01')

        Raises an `UnknownAttributeError <#half_orm.relation_errors.UnknownAttributeError>`_:
            >>> Person(lost_name='Lagaffe')
            [...]UnknownAttributeError: ERROR! Unknown attribute: {'lost_name'}.
    """
    _ho_fields_aliases = {}

    def __init__(self, **kwargs):
        _fqrn = ""
        """The names of the arguments must correspond to the names of the columns in the relation.
        """
        module = __import__(self.__module__, globals(), locals(), ['FKEYS_PROPERTIES', 'FKEYS'], 0)
        #TODO: remove in release 1.0.0
        if hasattr(module, 'FKEYS_PROPERTIES') or hasattr(module, 'FKEYS'):
            mod_fkeys = utils.Color.bold(module.__name__ + '.FKEYS')
            err = f'''{mod_fkeys} variable is no longer supported!\n'''
            err += f'''\tUse the "{utils.Color.bold(self.__class__.__name__ + '.Fkeys')}"''' + \
                ''' class attribute instead.\n'''
            raise DeprecationWarning(err)
        self._ho_fk_loop = set()
        self._ho_fields = {}
        self._ho_pkey = {}
        self._ho_fkeys = OrderedDict()
        self._ho_fkeys_attr = set()
        self._ho_fkeys_properties = False
        self._ho_join_to = {}
        self._ho_is_singleton = False
        self._ho_only = False
        self._ho_neg = False
        self._ho_set_fields()
        self._ho_set_fkeys()
        self._ho_query = ""
        self._ho_query_type = None
        self._ho_sql_query = []
        self._ho_sql_values = []
        self._ho_set_operators = _SetOperators(self)
        self._ho_select_params = {}
        self._ho_id_cast = None
        self._ho_check_columns(*kwargs.keys())
        _ = {self.__dict__[field_name].set(value)
            for field_name, value in kwargs.items() if value is not None}
        self._ho_isfrozen = True

    def __call__(self, **kwargs):
        return self.__class__(**kwargs)

    def _ho_check_columns(self, *args):
        "Check that the args are actual columns of the relation"
        columns = {elt.replace('"', '') for elt in args}
        if columns.intersection(self._ho_fields.keys()) != columns:
            diff = columns.difference(self._ho_fields.keys())
            raise relation_errors.UnknownAttributeError(', '.join([elt for elt in args if elt in diff]))

    #@utils.trace
    def _fkey_where(self, where, values):
        _, _, fk_fields, fk_query, fk_values = self._what()
        if fk_fields:
            fk_where = " and ".join([f"({a}) in ({b})" for a, b in zip(fk_fields, fk_query)])
            if fk_where:
                where = f"{where} and {fk_where}"
            values += fk_values
        return where, values

    def _ho_add_returning(self, query, *args) -> str:
        "Adds the SQL returning clause to the query"
        if args:
            returning = ', '.join(args)
            return f'{query} returning {returning}'
        return query

    def ho_unfreeze(self):
        "Allow to add attributs to a relation"
        self._ho_isfrozen = False

    def ho_freeze(self):
        "set _ho_isfrozen to True."
        self._ho_isfrozen = True

    def __setattr__(self, key, value):
        """Sets an attribute as long as _ho_isfrozen is False

        The foreign keys properties are not detected by hasattr
        hence the line `_ = self.__dict__[key]` to double check if
        the attribute is really present.
        """
        if not hasattr(self, '_ho_isfrozen'):
            object.__setattr__(self, '_ho_isfrozen', False)
        if self._ho_isfrozen and not hasattr(self, key):
            raise relation_errors.IsFrozenError(self.__class__, key)
        if self.__dict__.get(key) and isinstance(self.__dict__[key], Field):
            self.__dict__[key].set(value)
            return
        object.__setattr__(self, key, value)

    @property
    def ho_id(self):
        """Return the _ho_id_cast or the id of the relation.
        """
        return self._ho_id_cast or id(self)

    @property
    def ho_only(self):
        "Returns the value of self._ho_only"
        return self._ho_only
    @ho_only.setter
    def ho_only(self, value):
        """Set the value of self._ho_only. Restrict the values of a query to
        the elements of the relation (no inherited values).
        """
        if value not in {True, False}:
            raise ValueError(f'{value} is not a bool!')
        self._ho_only = value

    def _py_field_name(self, name, field_num):
        py_name = self._ho_fields_aliases.get(name, name)
        error = utils.check_attribute_name(py_name)
        if error is not None:
            utils.warning(f"{error}\n", 'HALFORM')
            return f'column{field_num}'
        return py_name

    def _ho_set_fields(self):
        """Initialise the fields of the relation."""
        _fields_metadata = self._ho_model._fields_metadata(self._t_fqrn)

        for field_name, f_metadata in _fields_metadata.items():
            field = Field(field_name, self, f_metadata)
            field_name = self._py_field_name(field_name, f_metadata['fieldnum'])
            self._ho_fields[field_name] = field
            setattr(self, field_name, field)
            if field._is_part_of_pk():
                self._ho_pkey[field_name] = field

    def _ho_set_fkeys(self):
        """Initialisation of the foreign keys of the relation"""
        #pylint: disable=import-outside-toplevel
        from half_orm.fkey import FKey

        _fkeys_metadata = self._ho_model._fkeys_metadata(self._t_fqrn)
        for fkeyname, f_metadata in _fkeys_metadata.items():
            self._ho_fkeys[fkeyname] = FKey(fkeyname, self, *f_metadata)
        if hasattr(self.__class__, 'Fkeys') and not self._ho_fkeys_properties:
            for key, value in self.Fkeys.items():
                try:
                    if key != '': # we skip empty keys
                        setattr(self, key, self._ho_fkeys[value])
                        self._ho_fkeys_attr.add(key)
                except KeyError as exp:
                    raise relation_errors.WrongFkeyError(self, value) from exp
        self._ho_fkeys_properties = True

    @classmethod
    def _ho_dataclass_name(cls):
        database, schema, relation = cls._t_fqrn
        schemaname = ''.join([elt.capitalize() for elt in schema.split('.')])
        relationname = ''.join([elt.capitalize() for elt in relation.split('_')])
        return f'DC_{schemaname}{relationname}'

    def ho_dict(self):
        """Returns a dictionary containing only the values of the fields
        that are set."""
        return {key:field.value for key, field in self._ho_fields.items() if field.is_set()}

    def keys(self):
        return self._ho_fields.keys()

    def items(self):
        for key, field in self._ho_fields.items():
            yield key, field.value

    def __getitem__(self, key):
        return self._ho_fields[key].value

    def _to_dict_val_comp(self):
        """Returns a dictionary containing the values and comparators of the fields
        that are set."""
        return {key:(field._comp(), field.value) for key, field in
                self._ho_fields.items() if field.is_set()}

    def __repr__(self):

        fkeys_usage = """\
To use the foreign keys as direct attributes of the class, copy/paste the Fkeys below into
your code as a class attribute and replace the empty string key(s) with the alias(es) you
want to use. The aliases must be unique and different from any of the column names. Empty
string keys are ignored.

Fkeys = {"""

        rel_kind = self._ho_kind
        ret = []
        database, schema, relation = self._t_fqrn
        ret.append(f"DATABASE: {database}")
        ret.append(f"SCHEMA: {schema}")
        ret.append(f"{rel_kind.upper()}: {relation}\n")
        if self._ho_metadata['description']:
            ret.append(f"DESCRIPTION:\n{self._ho_metadata['description']}")
        ret.append('FIELDS:')
        mx_fld_n_len = 0
        for field_name in self._ho_fields.keys():
            mx_fld_n_len = max(mx_fld_n_len, len(field_name))
        for field_name, field in self._ho_fields.items():
            field_desc = f"- {field_name}:{' ' * (mx_fld_n_len + 1 - len(field_name))}{repr(field)}"
            error = utils.check_attribute_name(field.name)
            if error and not field.name in self._ho_fields_aliases:
                field_desc = f'{field_desc} --- FIX ME! {error}'
            ret.append(field_desc)
        ret.append('')
        pkey = self._ho_model._pkey_constraint(self._t_fqrn)
        if pkey:
            ret.append(f"PRIMARY KEY ({', '.join(pkey)})")
        for uniq in self._ho_model._unique_constraints_list(self._t_fqrn):
            ret.append(f"UNIQUE CONSTRAINT ({', '.join(uniq)})")
        if self._ho_fkeys.keys():
            plur = 'S' if len(self._ho_fkeys) > 1 else ''
            ret.append(f'FOREIGN KEY{plur}:')
            for fkey in self._ho_fkeys.values():
                ret.append(repr(fkey))
            ret.append('')
            ret.append(fkeys_usage)
            for fkey in self._ho_fkeys:
                ret.append(f"    '': '{fkey}',")
            ret.append('}')
        return '\n'.join(ret)

    def ho_is_set(self):
        """Return True if one field at least is set or if self has been
        constrained by at least one of its foreign keys or self is the
        result of a combination of Relations (using set operators).
        """
        joined_to = False
        for _, jt_ in self._ho_join_to.items():
            jt_id = id(jt_)
            if jt_id in self._ho_fk_loop:
                raise RuntimeError("Can't set Fkey on the same object")
            self._ho_fk_loop.add(jt_id)
            joined_to |= jt_.ho_is_set()
        self._ho_fk_loop = set()
        return (joined_to or bool(self._ho_set_operators.operator) or bool(self._ho_neg) or
                bool({field.value for field in self._ho_fields.values() if field.is_set()}))

    def _get_set_fields(self):
        """Returns a list containing only the fields that are set."""
        return [field for field in self._ho_fields.values() if field.is_set()]

    #@utils.trace
    def _walk_op(self, rel_id_, out=None, _fields_=None):
        """Walk the set operators tree and return a list of SQL where
        representation of the query with a list of the fields of the query.
        """
        if out is None:
            out = []
            _fields_ = []
        if self._ho_set_operators.operator:
            if self._ho_neg:
                out.append("not (")
            out.append("(")
            left = self._ho_set_operators.left
            left._ho_query_type = self._ho_query_type
            left._walk_op(rel_id_, out, _fields_)
            if self._ho_set_operators.right is not None:
                out.append(f" {self._ho_set_operators.operator}\n    ")
                right = self._ho_set_operators.right
                right._ho_query_type = self._ho_query_type
                right._walk_op(rel_id_, out, _fields_)
            out.append(")")
            if self._ho_neg:
                out.append(")")
        else:
            out.append(self._where_repr(rel_id_))
            _fields_ += self._get_set_fields()
        return out, _fields_

    def _ho_sql_id(self):
        """Returns the FQRN as alias for the sql query."""
        return f"{self._qrn} as r{self.ho_id}"

    #@utils.trace
    def _get_from(self, orig_rel=None, deja_vu=None):
        """Constructs the _ho_sql_query and gets the _ho_sql_values for self."""
        if deja_vu is None:
            orig_rel = self
            self._ho_sql_query = [self._ho_sql_id()]
            deja_vu = {self.ho_id:[(self, None)]}
        for fkey, fk_rel in self._ho_join_to.items():
            fk_rel._ho_query_type = orig_rel._ho_query_type
            if fk_rel.ho_id not in deja_vu:
                deja_vu[fk_rel.ho_id] = []
            # elif (fk_rel, fkey) in deja_vu[fk_rel.ho_id] or fk_rel is orig_rel:
            #     #sys.stderr.write(f"déjà vu in from! {fk_rel._fqrn}\n")
            #     continue
            fk_rel._get_from(orig_rel, deja_vu)
            deja_vu[fk_rel.ho_id].append((fk_rel, fkey))
            _, where, values = fk_rel._where_args()
            where = f" and {where}"
            orig_rel._ho_sql_query.insert(1, f'join {fk_rel._ho_sql_id()} on')
            orig_rel._ho_sql_query.insert(2, fkey._join_query(self))
            orig_rel._ho_sql_query.append(where)
            orig_rel._ho_sql_values += values

    #@utils.trace
    def _where_repr(self, rel_id_):
        where_repr = []
        for field in self._get_set_fields():
            where_repr.append(field._where_repr(self._ho_query_type, rel_id_))
        where_repr = ' and '.join(where_repr) or '1 = 1'
        ret = f"({where_repr})"
        if self._ho_neg:
            ret = f"not ({ret})"
        return ret

    #@utils.trace
    def _where_args(self, *args):
        """Returns the what, where and values needed to construct the queries.
        """
        rel_id_ = self.ho_id
        what = f'r{rel_id_}.*'
        if args:
            what = ', '.join([f'r{rel_id_}.{arg}' for arg in args])
        s_where, set_fields = self._walk_op(rel_id_)
        s_where = ''.join(s_where)
        return what, s_where, set_fields

    #@utils.trace
    def _prep_query(self, query_template, *args):
        """Prepare the SQL query to be executed."""
        from half_orm.fkey import FKey

        self._ho_sql_values = []
        self._ho_query_type = 'select'
        what, where, values = self._where_args(*args)
        where = f"where {where}"
        self._get_from()
        # remove duplicates
        for idx, elt in reversed(list(enumerate(self._ho_sql_query))):
            if elt.find('join') == 0 and self._ho_sql_query.count(elt) > 1:
                self._ho_sql_query[idx] = 'and'
        # check that fkeys are fkeys
        for fkey_name in self._ho_fkeys_attr:
            fkey_cls = self.__dict__[fkey_name].__class__
            if fkey_cls != FKey:
                raise RuntimeError(
                    f'self.{fkey_name} is not a FKey (got a {fkey_cls.__name__} object instead).\n'
                    f'- use: self.{fkey_name}.set({fkey_cls.__name__}(...))\n'
                    f'- not: self.{fkey_name} = {fkey_cls.__name__}(...)'
                    )
        final_values = []
        for field in values:
            if isinstance(field.value, (list, tuple, set)):
                for value in field.value:
                    final_values.append(value)
            else:
                final_values.append(field.value)
        return (
            query_template.format(
                what,
                self._ho_only and "only" or "",
                ' '.join(self._ho_sql_query), where),
            final_values)

    #@utils.trace
    def _ho_prep_select(self, *args):
        distinct = self._ho_select_params.get('distinct', '')
        query_template = f"select {distinct} {{}} from {{}} {{}} {{}}"
        query, values = self._prep_query(query_template, *args)
        values = tuple(self._ho_sql_values + values)
        if 'order_by' in self._ho_select_params:
            query = f"{query} order by {self._ho_select_params['order_by']}"
        if 'limit' in self._ho_select_params:
            query = f"{query} limit {self._ho_select_params['limit']}"
        if 'offset' in self._ho_select_params:
            query = f"{query} offset {self._ho_select_params['offset']}"
        return query, values

    def ho_distinct(self, dist=True):
        """Set distinct in SQL select request."""
        distinct = 'distinct'
        if dist not in {True, False}:
            raise ValueError('ho_distinct argument must be either True or False!')
        if dist in {False, None}:
            distinct = ''
        self._ho_select_params['distinct'] = distinct
        return self

    def ho_unaccent(self, *fields_names):
        "Sets unaccent for each field listed in fields_names"
        for field_name in fields_names:
            if not isinstance(self.__dict__[field_name], Field):
                raise ValueError(f'{field_name} is not a Field!')
            self.__dict__[field_name].unaccent = True
        return self

    def ho_order_by(self, _order_):
        """Set SQL order by according to the "order" string passed

        @order string example :
        "field1, field2 desc, field3, field4 desc"
        """
        self._ho_select_params['order_by'] = _order_
        return self

    def ho_limit(self, _limit_):
        """Set limit for the next SQL select request."""
        if _limit_:
            self._ho_select_params['limit'] = int(_limit_)
        elif 'limit' in self._ho_select_params:
            self._ho_select_params.pop('limit')
        return self

    def ho_offset(self, _offset_):
        """Set the offset for the next SQL select request."""
        self._ho_select_params['offset'] = int(_offset_)
        return self

    #@utils.trace
    def _update_args(self, **kwargs):
        """Returns the what, where an values for the update query."""
        what_fields = []
        new_values = []
        self._ho_query_type = 'update'
        _, where, values = self._where_args()
        where = f" where {where}"
        for field_name, new_value in kwargs.items():
            what_fields.append((
                self._ho_fields[field_name].name,
                self._ho_fields[field_name].value is not None and f"::{self._ho_fields[field_name].sql_type}" or ''))
            new_values.append(new_value)
        what = ", ".join([f'"{elt[0]}" = %s{elt[1]}' for elt in what_fields])
        return what, where, new_values + values

    #@utils.trace
    def _what(self):
        """Returns the constrained fields and foreign keys.
        """
        set_fields = self._get_set_fields()
        fields_names = [
            f'"{field.name}"' for field in self._ho_fields.values() if field.is_set()]
        fk_fields = []
        fk_queries = ''
        fk_values = []
        for fkey in self._ho_fkeys.values():
            fk_prep_select = fkey._fkey_prep_select()
            if fk_prep_select is not None:
                fk_values += list(fkey.values()[0])
                fk_fields += fk_prep_select[0]
                fk_queries = ["%s" for _ in range(len(fk_values))]

        return fields_names, set_fields, fk_fields, fk_queries, fk_values

    @classmethod
    def ho_description(cls):
        """Returns the description (comment) of the relation
        """
        description = cls._ho_metadata['description']
        if description:
            description = description.strip()
        return description or 'No description available'

    def ho_cast(self, qrn):
        """Cast a relation into another relation.

        TODO: check that qrn inherits self (or is inherited by self)?
        """
        new = self._ho_model._import_class(qrn)(**self._to_dict_val_comp())
        new._ho_id_cast = id(self)
        new._ho_join_to = self._ho_join_to
        new._ho_set_operators = self._ho_set_operators
        return new

    def _set_op_(self, operator=None, right=None):
        """Si l'opérateur du self est déjà défini, il faut aller modifier
        l'opérateur du right ???
        On crée un nouvel objet sans contrainte et on a left et right et opérateur
        """
        def check_fk(new, jt_list):
            """Sets the _ho_join_to dictionary for the new relation.
            """
            for fkey, rel in jt_list.items():
                if rel is self:
                    rel = new
                new._ho_join_to[fkey] = rel
        new = self(**self._to_dict_val_comp())
        new._ho_id_cast = self._ho_id_cast
        if operator:
            new._ho_set_operators.left = self
            new._ho_set_operators.operator = operator
        dct_join = self._ho_join_to
        if right is not None:
            new._ho_set_operators.right = right
            dct_join.update(right._ho_join_to)
        check_fk(new, dct_join)
        return new

    def __and__(self, right):
        return self._set_op_("and", right)
    def __iand__(self, right):
        self = self & right
        return self

    def __or__(self, right):
        return self._set_op_("or", right)
    def __ior__(self, right):
        self = self | right
        return self

    def __sub__(self, right):
        return self._set_op_("and not", right)
    def __isub__(self, right):
        self = self - right
        return self

    def __neg__(self):
        new = self._set_op_(self._ho_set_operators.operator, self._ho_set_operators.right)
        new._ho_neg = not self._ho_neg
        return new

    def __xor__(self, right):
        return (self | right) - (self & right)
    def __ixor__(self, right):
        self = self ^ right
        return self

    def __eq__(self, right):
        if id(self) == id(right):
            return True
        return self in right and right in self

    def __enter__(self):
        """Context management entry

        Returns self in a transaction context.

        Example usage:
        with relation as rel:
            rel.ho_update(col=new_val)

        Equivalent to (in a transaction context):
        rel = relation.ho_select()
        for elt in rel:
            new_elt = relation(**elt)
            new_elt.ho_update(col=new_val)
        """
        self.ho_transaction._enter(self._ho_model)
        return self

    def __exit__(self, *__):
        """Context management exit

        """
        self.ho_transaction._exit(self._ho_model)
        return False

def transaction(fct):
    """Decorator. Enforces every SQL insert, update or delete operation called within a
    Relation method to be executed in a transaction.
    
    Usage:
        from relation import transaction
        class Person(model.get_relation_class(actor.person)):
            [...]
            @transaction
            def insert_many(self, **data):
                for d_pers in **data:
                    self(**d_pers).ho_insert()
            [...]
        
        Pers().insert_many([{...}, {...}])

    """
    def wrapper(self, *args, **kwargs):
        with Transaction(self._ho_model):
            return fct(self, *args, **kwargs)
    return wrapper

REL_CLASS_NAMES = {
    'r': 'Table',
    'p': 'Partioned table',
    'v': 'View',
    'm': 'Materialized view',
    'f': 'Foreign data'}
